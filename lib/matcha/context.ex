defmodule Matcha.Context do
  @moduledoc """
  Different types of match spec are intended to be used for different purposes,
  and support different instructions in their bodies for different use-cases.

  The modules implementing the `Matcha.Context` behaviour define the different types of `Matcha.Spec`,
  provide documentation for what specialized instructions that type supports, and are used during
  Elixir-to-match spec conversion as a concrete function definition to use when expanding instructions
  (since most of these specialized instructions do not exist anywhere as an actual functions,
  this lets the Elixir compiler complain about invalid instructions as `UndefinedFunctionError`s).

  ### Predefined contexts

  Currently there are three applications of match specs supported:

    - `:filter_map`:

        Matchspecs intended to be used to filter/map over an in-memory list in an optimized fashion.
        These types of match spec reference the `Matcha.Context.FilterMap` module.

    - `:match`:

        Matchspecs intended to be used to match over an in-memory list in an optimized fashion.
        These types of match spec reference the `Matcha.Context.Match` module.

    - `:table`:

        Matchspecs intended to be used to efficiently select data from BEAM VM "table"
        tools, such as `:ets`, `:dets`, and `:mnesia`, and massage the values returned.
        These types of match spec reference the `Matcha.Context.Table` module.

    - `:trace`:

        Matchspecs intended to be used to instruct tracing utilities such as
        `:dbg` and `:recon_trace` exactly what function calls with what arguments to trace,
        and allows invoking special trace command instructions in response.
        These types of match spec reference the `Matcha.Context.Trace` module.

  ### Custom contexts

  The context mechanism is technically extensible: any module can implement the `Matcha.Context`
  behaviour, define the callbacks, and list public no-op functions to allow their usage in
  specs compiled with that context (via `Matcha.spec(CustomContext) do...`).

  In practice there is little point in defining a custom context:
  the supported use-cases for match specs are tightly coupled to the erlang language,
  and `Matcha` covers all of them with its provided contexts, which should be sufficient for any application.
  The module+behaviour+callback implementation used in `Matcha` is less about offering extensibility,
  but instead used to simplify special-casing in `Matcha.Spec` function implementations,
  raise Elixir-flavored errors when an invalid instruction is used in the different types of spec,
  and provide a place to document what they do when invoked.

  """

  defmacro __using__(_opts \\ []) do
    quote do
      @behaviour unquote(__MODULE__)
      @compile {:inline, __erl_type__: 0, __default_match_target__: 0}
    end
  end

  alias Matcha.Error
  alias Matcha.Source

  alias Matcha.Spec

  @type t :: module()

  @core_context_aliases [
    filter_map: Matcha.Context.FilterMap,
    match: Matcha.Context.Match,
    table: Matcha.Context.Table,
    trace: Matcha.Context.Trace
  ]
  def __core_context_aliases__, do: @core_context_aliases

  @doc """
  Which primitive erlang context this context module wraps.
  """
  @callback __erl_type__() :: Source.type()

  @doc """
  A default value to use when executing match specs in this context.

  This function is used to provide `Matcha.Source.test/3` with a target value to test against,
  in situations where it is being used to simply validate the match spec itself,
  but we do not acutally care if the input matches the spec.

  This value, when passed to this context's `c:Matcha.Context.__valid_match_target__/1` callback,
  must produce a `true` value.
  """
  @callback __default_match_target__() :: any

  @doc """
  A validator that runs before executing a match spec against a `target` in this context.

  This validator is run before any match specs are executed on inputs to `Matcha.Source.test/3`,
  and all elements of the enumerable input to `Matcha.Source.run/3`.

  If this function returns false, the match spec will not be executed, instead
  returning a `t:Matcha.Error.error_problem` with a `t:Matcha.Error.message`
  generated by the `c:Matcha.Context.__invalid_match_target_error_message__/1` callback.
  """
  @callback __valid_match_target__(match_target :: any) :: boolean()

  @doc """
  Describes an issue with a test target.

  Invoked to generate a `t:Matcha.Error.message` when `c:Matcha.Context.__valid_match_target__/1` fails.
  """
  @callback __invalid_match_target_error_message__(match_target :: any) :: String.t()

  @doc """
  Allows this context module to modify match specs before their execution.

  This hook is the main entrypoint for creating custom contexts,
  allowing them to augment the match spec with new behaviour when executed in this context.

  Care must be taken to handle the results of the modified match spec after execution correctly,
  before they are returned to the caller. This should be implemented in the callbacks:

  - `c:Matcha.Context.__transform_erl_run_results__/1`
  - `c:Matcha.Context.__transform_erl_test_result__/1`
  - `c:Matcha.Context.__emit_erl_test_result__/1`
  """
  @callback __prepare_source__(source :: Source.uncompiled()) ::
              {:ok, new_source :: Source.uncompiled()} | {:error, Error.problems()}

  @callback __emit_erl_test_result__(result :: any) :: boolean

  @callback __transform_erl_test_result__(result :: any) ::
              {:ok, result :: any} | {:error, Error.problems()}

  @callback __transform_erl_run_results__(results :: [any]) ::
              {:ok, results :: [any]} | {:error, Error.problems()}

  @doc """
  Determines whether or not specs in this context can be compiled.
  """
  @spec supports_compilation?(t) :: boolean
  def supports_compilation?(context) do
    context.__erl_type__() == :table
  end

  @doc """
  Determines whether or not specs in this context can used in tracing.
  """
  @spec supports_tracing?(t) :: boolean
  def supports_tracing?(context) do
    context.__erl_type__() == :trace
  end

  @doc """
  Resolves shortcut references to the core Matcha context modules.
  """
  @spec resolve(atom() | t) :: t | no_return

  for {alias, context} <- @core_context_aliases do
    def resolve(unquote(alias)), do: unquote(context)
  end

  def resolve(context) when is_atom(context) do
    context.__erl_type__()
  rescue
    UndefinedFunctionError ->
      reraise ArgumentError,
              [
                message:
                  "`#{inspect(context)}` is not one of: " <>
                    (Keyword.keys(@core_context_aliases)
                     |> Enum.map_join(", ", &"`#{inspect(&1)}`")) <>
                    " or a module that implements `Matcha.Context`"
              ],
              __STACKTRACE__
  else
    _ -> context
  end

  def resolve(context) do
    raise ArgumentError,
      message:
        "`#{inspect(context)}` is not one of: " <>
          (Keyword.keys(@core_context_aliases)
           |> Enum.map_join(", ", &"`#{inspect(&1)}`")) <>
          " or a module that implements `Matcha.Context`"
  end

  @spec run(Matcha.Spec.t(), Enumerable.t()) ::
          {:ok, list} | {:error, Matcha.Error.problems()}
  def run(%Spec{context: context} = spec, enumerable) do
    case context.__prepare_source__(spec.source) do
      {:ok, source} ->
        match_targets = Enum.to_list(enumerable)

        results =
          if supports_compilation?(context) do
            source
            |> Source.compile()
            |> Source.run(match_targets)
          else
            do_run_without_compilation(match_targets, spec, source)
          end

        spec.context.__transform_erl_run_results__(results)

      {:error, problems} ->
        {:error, problems}
    end
  end

  defp do_run_without_compilation(match_targets, spec, source) do
    match_targets
    |> Enum.reduce([], fn match_target, results ->
      case do_test(source, spec.context, match_target) do
        {:ok, result} ->
          case spec.context.__emit_erl_test_result__(result) do
            {:emit, result} ->
              [result | results]

            :no_emit ->
              {[], spec}
          end

        {:error, problems} ->
          raise Spec.Error,
            source: spec,
            details: "when running match spec",
            problems: problems
      end
    end)
    |> :lists.reverse()
  end

  def stream(%Spec{context: context} = spec, enumerable) do
    case context.__prepare_source__(spec.source) do
      {:ok, source} ->
        Stream.transform(enumerable, {spec, source}, fn match_target, {spec, source} ->
          spec.context.__valid_match_target__(match_target)
          do_stream_test(match_target, spec, source)
        end)

      {:error, problems} ->
        {:error, problems}
    end
  end

  defp do_stream_test(match_target, spec, source) do
    case do_test(source, spec.context, match_target) do
      {:ok, result} ->
        case spec.context.__emit_erl_test_result__(result) do
          {:emit, result} ->
            case spec.context.__transform_erl_run_results__([result]) do
              {:ok, results} ->
                {:ok, results}

              {:error, problems} ->
                raise Spec.Error,
                  source: spec,
                  details: "when streaming match spec",
                  problems: problems
            end

          :no_emit ->
            {[], spec}
        end

      {:error, problems} ->
        raise Spec.Error,
          source: spec,
          details: "when streaming match spec",
          problems: problems
    end
  end

  @spec test(Spec.t()) ::
          {:ok, Source.match_result()} | {:error, Matcha.Error.problems()}
  def test(%Spec{context: context} = spec) do
    test(spec, context.__default_match_target__())
  end

  @spec test(Spec.t(), Source.match_target()) ::
          {:ok, Source.match_result()} | {:error, Matcha.Error.problems()}
  def test(%Spec{context: context} = spec, match_target) do
    case context.__prepare_source__(spec.source) do
      {:ok, source} ->
        if context.__valid_match_target__(match_target) do
          do_test(source, context, match_target)
        else
          {:error,
           [
             error: context.__invalid_match_target_error_message__(match_target)
           ]}
        end

      {:error, problems} ->
        {:error, problems}
    end
  end

  defp do_test(source, context, match_target) do
    source
    |> Source.test(context.__erl_type__(), match_target)
    |> context.__transform_erl_test_result__()
  end
end
